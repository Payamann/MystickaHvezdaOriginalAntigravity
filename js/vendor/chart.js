/*!
 * Chart.js v4.4.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).Chart = e() }(this, (function () {
    "use strict"; var t = Object.freeze({ __proto__: null, get Colors() { return Go }, get Decimation() { return Qo }, get Filler() { return ma }, get Legend() { return ya }, get SubTitle() { return Ma }, get Title() { return ka }, get Tooltip() { return Ba } }); function e() { } const i = (() => { let t = 0; return () => t++ })(); function s(t) { return null == t } function n(t) { if (arguments.length > 1) for (let e = 1; e < arguments.length; e++)arguments[e](t); else { const e = t.payload; e && e.error && e.error } } function o(t, e, i) { let s, n, o; for (s = 0, n = t.length; s < n; s++)o = t[s][i], t[s].removeEventListener(e, o) } function a(t, e, i, s) { let n, o, a; for (n = 0, o = t.length; n < o; n++)a = t[n], a.removeEventListener(e, i, s), a.addEventListener(e, i, s) } function r(t, e) { let i; for (i = 0; i < t.length; i++)e(t[i], i) } function l(t, e, i) { let s, n, o; for (s = 0, n = t.length; s < n; s++)o = t[s], e.call(i, o, s, t) } function h(t, e, i) { let s, n, o; for (s = 0, n = t.length; s < n; s++)if (o = t[s], e.call(i, o, s, t)) return o } function c(t, e) { let i, s, n; for (i = 0, s = t.length; i < s; i++)if (n = t[i], e(n, i, t)) return n } function d(t, e) { let i, s, n; for (i = t.length - 1; i >= 0; i--)if (n = t[i], e(n, i, t)) return n } function u(t, e) { return c(t, (t => t.axis === e)) } function f(t, e) { return c(t, (t => t.id === e)) } function g(t) { const e = "string" == typeof t, i = e ? parseInt(t, 10) : t; return isNaN(i) ? 0 : i } function p(t, e) { return t.map((t => t[e])) } function m(t, e) { const i = t.indexOf(e); return -1 === i ? t : t.slice(0, i).concat(t.slice(i + 1)) } function b(t) { for (const e of t) if (void 0 !== e) return e } function x(t, e, i, s) { return t.filter((t => v(t, e, i, s))) } function _(t, e, i, s) { const n = x(t, e, i, s); t.length = 0, t.push(...n) } function y(t, e, i, s) { const n = []; for (let o = 0, a = t.length; o < a; ++o)v(t[o], e, i, s) && n.push(t[o]); return n } function v(t, e, i, s) { return !s || t[e] === i } function M(t, e) { const i = t.length; return i ? t[i - 1] : e } function w(t, e) { return t.length > e ? t.slice(Math.max(0, t.length - e)) : t } function k(t, e) { return t.length > e && (t.length = e), t } function S(t) { return "number" == typeof t && isFinite(t) } function P(t) { return Number.isInteger(t) } function D(t) { return Math.PI * t / 180 } function C(t) { return 180 * t / Math.PI } function O(t) { if (!S(t)) return; let e = 1, i = 0; for (; Math.round(t * e) / e !== t;)e *= 10, i++; return i } function A(t) { const e = Math.log10(Math.abs(t)), i = Math.floor(e), s = Math.ceil(e); return s - i } function T(t) { const e = Math.log10(Math.abs(t)); return Math.sign(t) * Math.pow(10, Math.floor(e)) } function L(t, e) { return Math.round(t * Math.pow(10, e)) / Math.pow(10, e) } function E(t) { const e = t.toString().split("."); return e.length > 1 ? e[1].length : 0 } function R(t, e, i) { let s = 0, n = t.length - 1; if (i < t[0]) return -1; if (i > t[n]) return n; for (; s <= n;) { const o = s + n >> 1, a = t[o]; if (a < i) s = o + 1; else { if (!(a > i)) return o; n = o - 1 } } return (i - t[n]) / (t[s] - t[n]) >= e ? s : n } function I(t, e) { return t - e } function z(t, e) { return t - e } function F(t, e) { return t === e } function V(t) { return t.length > 0 ? t.reduce(((t, e) => Math.max(t, e))) : 1 / 0 } function B(t) { return t.length > 0 ? t.reduce(((t, e) => Math.min(t, e))) : -1 / 0 } function W(t) { const e = t.length; let i, s = 0; for (i = 0; i < e; i++)s += t[i]; return e ? s / e : 0 } function N(t) { const e = t.length, i = []; let s = 0; for (; s < e; s++)t[s] && (i.push(t[s]), s++); return i.length ? i[Math.floor(i.length / 2)] : 0 } function H(t, e) { const i = Math.hypot(e.x - t.x, e.y - t.y); return { angle: Math.atan2(i, e.y - t.y), distance: i } } function j(t) { return Math.min(Math.max(t, -1), 1) } function $(t, e, i) { return Math.max(Math.min(t, i), e) } function Y(t, e, i) { return t = g(t), e = g(e), i = g(i), t < 0 ? Math.round(Math.min(255, (i < 0 ? 0 : i) - t * e)) : 0 === e ? t : Math.round(Math.min(255, (i < 0 ? 0 : i) + (255 - t) * e)) } function U(t) { return t % 2 == 0 } const X = (t, e, i, s = 0) => Math.min(Math.max(s, 1 + t.length - e), i); function q(t) { return void 0 === t || null === t } function K(t) { return "object" == typeof t && null !== t && "[object Array]" === Object.prototype.toString.call(t) } function G(t) { return "object" == typeof t && null !== t && "[object Object]" === Object.prototype.toString.call(t) } function Z(t) { return "number" == typeof t } function Q(t) { return void 0 === t } function J(t) { return null === t } function tt(t) { return "object" == typeof t && null !== t } function et(t) { return "[object CanvasPattern]" === Object.prototype.toString.call(t) || "[object CanvasGradient]" === Object.prototype.toString.call(t) } function it(t) { function e(t, s) { const n = i.get(t); if (n) return n; const o = s(); return i.set(t, o), o } const i = new Map; return function (i) { return e(i, (() => t.call(this, i))) } } function st(t) { return 180 * t / Math.PI } function nt(t) { return t * Math.PI / 180 } function ot(t) { return "string" == typeof t } function at(t) { const e = t && t.canvas, i = e && e.getContext("2d"); return !(!i || !i.getContextAttributes || !i.getContextAttributes().willReadFrequently) } function rt(t) { if ("string" == typeof t) { const e = parseInt(t, 10); if (t.indexOf("%") > -1) return e / 100; if (t.indexOf("px") > -1) return e; if (-1 === t.indexOf(".")) return e } return t } function lt(t, e) { return s(t) ? e : t } const ht = { x: t => t.x, y: t => t.y }; function ct(t, e) { let i, s, n, o; for (i = 0, s = t.length; i < s; ++i)n = t[i], o = n[e], o && (n[e] = new Date(o)) } function dt(t) { if (t && "function" == typeof t.toUTCString) return "string" == typeof t.toISOString ? t.toISOString() : t.toUTCString(); return t } function ut(t) { if ("string" != typeof t) return t; if (t = t.trim(), t.includes("clamp(")) { const e = t.match(/clamp\(([^)]+)\)/); if (e) { const t = e[1].split(","); return t.length < 3 ? t : parseFloat(t[1]) } } if (t.includes("max(")) { const e = t.match(/max\(([^)]+)\)/); if (e) { const t = e[1].split(","); return t.length < 2 ? t : parseFloat(t[0]) } } if (t.includes("min(")) { const e = t.match(/min\(([^)]+)\)/); if (e) { const t = e[1].split(","); return t.length < 2 ? t : parseFloat(t[0]) } } if (t.includes("calc(")) { const e = t.match(/calc\(([^)]+)\)/); if (e) try { return new Function("return " + e[1])() } catch (t) { } } return parseFloat(t) } function ft(t, e) { return t.toString().match(new RegExp(".{1," + e + "}", "g")) } const gt = (t, e, i, s) => t > e ? i : t < i ? e : t; function pt(t) { const e = function (t) { const e = t.length; if (e < 2) return !1; for (const i of t) if (isNaN(i)) return !1; return !0 }(t), i = new Array(t.length); let s; if (e) { const e = t, n = i; let o; for (s = 0, o = e.length; s < o; ++s)n[s] = e[s] } else { const e = t, n = i; let o; for (s = 0, o = e.length; s < o; ++s)n[s] = ut(e[s]) } return i } const mt = (t, e) => Math.min(Math.max(t, e.min), e.max); function bt(t, e, i, s) { return { x: t.x + i * (e.x - t.x), y: t.y + i * (e.y - t.y) } } function xt(t, e, i, s) { return { x: t.x + i * (e.x - t.x), y: "middle" === s ? t.y < e.y ? e.y : t.y : t.y + i * (e.y - t.y) } } function _t(t, e, i, s) { return t = t.rgb ? t.rgb : t, e = e.rgb ? e.rgb : e, s = s ? s : function (t) { return t.alpha ? t.alpha : 1 }, t && e ? function (t) { const e = function (t, e, i) { const s = t.length; let n, o = 0; for (n = 0; n < s; n++)o += t[n] && t[n].w || 0; const a = Math.floor(o * Math.random()); let r = 0; for (n = 0; n < s; n++) { if (t[n] && t[n].w && (r += t[n].w, r >= a)) return t[n] } }(i, 0, 0), s = e ? e : i; return s.col ? s.col : s }(t, e, i) || { r: Math.round(t.r + (e.r - t.r) * i), g: Math.round(t.g + (e.g - t.g) * i), b: Math.round(t.b + (e.b - t.b) * i), alpha: s(t) + (s(e) - s(t)) * i } : { r: 0, g: 0, b: 0, alpha: 0 } } function yt(t, e, i, s) { const n = t.length, o = e.length; if (n !== o) return !1; for (let a = 0; a < n; a++)if (t[a] !== e[a]) return !1; return !0 } function vt(t, e, i) { return Math.max(Math.min(t, i), e) } function Mt(t) { return t.x === void 0 || t.y === void 0 } function wt(t, e, i, s) { const n = { x: t.x, y: t.y, x2: t.x2, y2: t.y2, width: t.width, height: t.height }; return n.x = gt(n.x, e, i, s), n.y = gt(n.y, e, i, s), n.x2 = gt(n.x2, e, i, s), n.y2 = gt(n.y2, e, i, s), n.width = gt(n.width, e, i, s), n.height = gt(n.height, e, i, s), n } function kt(t, e, i, s) { const n = t.chartArea; return e.x >= n.left && e.x <= n.right && e.y >= n.top && e.y <= n.bottom } function St(t, e, i) { return "start" === e ? t : "end" === e ? i : (t + i) / 2 } function Pt(t, e, i, s) { const n = St(t, s.textAlign, i), o = e + s.lineHeight / 2; return { x: n, y: o } } function Dt(t, e) { return "x" === e ? t.x : t.y } function Ct(t, e) { return "x" === e ? t.width : t.height } function Ot(t, e, i) { return i ? function (t, e) { const i = t.x, s = t.y, n = e.x, o = e.y; return Math.sqrt(Math.pow(n - i, 2) + Math.pow(o - s, 2)) }(t, e) : function (t, e) { return Math.abs(t - e) }(t, e) } function At(t, e) { let i, s, n, o, a; for (i = 0, s = t.length; i < s; i++)if (n = t[i], i > 0 && i < s - 1 && (o = t[i - 1], a = t[i + 1], (n.x - o.x) * (a.x - n.x) < 0 || (n.y - o.y) * (a.y - n.y) < 0)) return !0; return !1 } const Tt = Number.EPSILON || 1e-14, Lt = (t, e, i, s) => ({ x: t.x + i * (e.x - t.x), y: t.y + i * (e.y - t.y) }), Et = (t, e, i, s) => ({ x: t.x + i * (e.x - t.x), y: "middle" === s ? i < .5 ? t.y : e.y : t.y + i * (e.y - t.y) }), Rt = (t, e, i, s) => ({ x: t.x + i * (e.x - t.x), y: "middle" === s ? i < .5 ? t.y : e.y : t.y + i * (e.y - t.y) }), It = (t, e, i, s) => ({ x: t.x + i * (e.x - t.x), y: t.y + i * (e.y - t.y) }); function zt(t, e, i, s) { const n = t.x, o = t.y, a = e.x, r = e.y, l = i.x, h = i.y; let c, d, u, f, g; return c = n * n + o * o, d = a * a + r * r, u = l * l + h * h, f = n * (r - h) + a * (h - o) + l * (o - r), g = 1 / (2 * f), { x: (c * (r - h) + d * (h - o) + u * (o - r)) * g, y: (c * (l - n) + d * (n - l) + u * (a - n)) * g, r: Math.sqrt(Math.pow(n - a, 2) + Math.pow(o - r, 2)) * Math.sqrt(Math.pow(a - l, 2) + Math.pow(r - h, 2)) * Math.sqrt(Math.pow(l - n, 2) + Math.pow(h - o, 2)) / (2 * Math.abs(f)) } } function Ft(t, e, i) { const s = t.length; if (0 === s) return 0; const n = t[0]; if (1 === s) return n; let o = n, a = n; for (let n = 1; n < s; ++n)o = Math.min(o, t[n]), a = Math.max(a, t[n]); return (a - o) / s } function Vt(t) { const e = t.length; let i, s = 0; for (i = 0; i < e; i++)s += t[i]; return e ? s / e : 0 } function Bt(t, e) { const i = t.length; if (0 === i) return 0; const s = Vt(t); let n = 0; for (let e = 0; e < i; e++)n += Math.pow(t[e] - s, 2); return Math.sqrt(n / (i + (e ? -1 : 0))) } function Wt(t, e) { const i = t.length; if (0 === i) return 0; const s = Vt(t); let n = 0; for (let e = 0; e < i; e++)n += Math.pow(t[e] - s, 2); return n / (i + (e ? -1 : 0)) } function Nt(t, e) { const i = t.length; if (0 === i) return 0; const s = Vt(t); let n, o = 0; for (n = 0; n < i; n++)o += Math.pow(t[n] - s, 2); return o / i } function Ht(t, e) { const i = t.length; if (0 === i) return 0; const s = Vt(t); let n, o = 0; for (n = 0; n < i; n++)o += t[n] * e[n]; return o - i * s * Vt(e) } function jt(t, e) { const i = t.length; if (0 === i) return 0; const s = Vt(t); let n, o = 0; for (n = 0; n < i; n++)o += t[n] - s; return o / i } function $t(t, e) { const i = t.length; if (0 === i) return 0; const s = Vt(t); let n, o = 0; for (n = 0; n < i; n++)o += Math.abs(t[n] - s); return o / i } function Yt(t, e) { const i = t.length; if (0 === i) return 0; const s = Vt(t); let n, o = 0; for (n = 0; n < i; n++)o += Math.pow(t[n] - s, 3); return o / i } function Ut(t, e) { const i = t.length; if (0 === i) return 0; const s = Vt(t); let n, o = 0; for (n = 0; n < i; n++)o += Math.pow(t[n] - s, 4); return o / i } function Xt() { for (var t = 0, e = 0, i = arguments.length; e < i; e++)t += arguments[e].length; var s = Array(t), n = 0; for (e = 0; e < i; e++)for (var o = arguments[e], a = 0, r = o.length; a < r; a++, n++)s[n] = o[a]; return s } function qt(t) { return null !== t && void 0 !== t } function Kt(t) { return "object" == typeof t && null !== t && "[object Array]" === Object.prototype.toString.call(t) } function Gt(t) { return "object" == typeof t && null !== t && "[object Object]" === Object.prototype.toString.call(t) } function Zt(t) { return "string" == typeof t } function Qt(t) { return "number" == typeof t } function Jt(t) { return void 0 === t } function te(t) { return null === t } function ee(t) { return "object" == typeof t && null !== t } function ie(t) { return "[object CanvasPattern]" === Object.prototype.toString.call(t) || "[object CanvasGradient]" === Object.prototype.toString.call(t) } function se(t) { function e(t, s) { const n = i.get(t); if (n) return n; const o = s(); return i.set(t, o), o } const i = new Map; return function (i) { return e(i, (() => t.call(this, i))) } } function ne(t) { return 180 * t / Math.PI } function oe(t) { return t * Math.PI / 180 } function ae(t) { return "string" == typeof t } function re(t) { const e = t && t.canvas, i = e && e.getContext("2d"); return !(!i || !i.getContextAttributes || !i.getContextAttributes().willReadFrequently) } function le(t) { if ("string" == typeof t) { const e = parseInt(t, 10); if (t.indexOf("%") > -1) return e / 100; if (t.indexOf("px") > -1) return e; if (-1 === t.indexOf(".")) return e } return t } function he(t, e) { return null == t ? e : t } function ce(t) { if ("string" != typeof t) return t; if (t = t.trim(), t.includes("clamp(")) { const e = t.match(/clamp\(([^)]+)\)/); if (e) { const t = e[1].split(","); return t.length < 3 ? t : parseFloat(t[1]) } } if (t.includes("max(")) { const e = t.match(/max\(([^)]+)\)/); if (e) { const t = e[1].split(","); return t.length < 2 ? t : parseFloat(t[0]) } } if (t.includes("min(")) { const e = t.match(/min\(([^)]+)\)/); if (e) { const t = e[1].split(","); return t.length < 2 ? t : parseFloat(t[0]) } } if (t.includes("calc(")) { const e = t.match(/calc\(([^)]+)\)/); if (e) try { return new Function("return " + e[1])() } catch (t) { } } return parseFloat(t) } function de(t, e) { return t.toString().match(new RegExp(".{1," + e + "}", "g")) } const ue = (t, e, i, s) => t > e ? i : t < i ? e : t; function fe(t) { const e = function (t) { const e = t.length; if (e < 2) return !1; for (const i of t) if (isNaN(i)) return !1; return !0 }(t), i = new Array(t.length); let s; if (e) { const e = t, n = i; let o; for (s = 0, o = e.length; s < o; ++s)n[s] = e[s] } else { const e = t, n = i; let o; for (s = 0, o = e.length; s < o; ++s)n[s] = ce(e[s]) } return i } const ge = (t, e) => Math.min(Math.max(t, e.min), e.max); function pe(t, e, i, s) { return { x: t.x + i * (e.x - t.x), y: t.y + i * (e.y - t.y) } } function me(t, e, i, s) { return { x: t.x + i * (e.x - t.x), y: "middle" === s ? t.y < e.y ? e.y : t.y : t.y + i * (e.y - t.y) } } function be(t, e, i, s) { return t = t.rgb ? t.rgb : t, e = e.rgb ? e.rgb : e, s = s ? s : function (t) { return t.alpha ? t.alpha : 1 }, t && e ? function (t) { const e = function (t, e, i) { const s = t.length; let n, o = 0; for (n = 0; n < s; n++)o += t[n] && t[n].w || 0; const a = Math.floor(o * Math.random()); let r = 0; for (n = 0; n < s; n++) { if (t[n] && t[n].w && (r += t[n].w, r >= a)) return t[n] } }(i, 0, 0), s = e ? e : i; return s.col ? s.col : s }(t, e, i) || { r: Math.round(t.r + (e.r - t.r) * i), g: Math.round(t.g + (e.g - t.g) * i), b: Math.round(t.b + (e.b - t.b) * i), alpha: s(t) + (s(e) - s(t)) * i } : { r: 0, g: 0, b: 0, alpha: 0 } } function xe(t, e, i, s) { const n = t.length, o = e.length; if (n !== o) return !1; for (let a = 0; a < n; a++)if (t[a] !== e[a]) return !1; return !0 } function _e(t, e, i) { return Math.max(Math.min(t, i), e) } function ye(t) { return t.x === void 0 || t.y === void 0 } function ve(t, e, i, s) { const n = { x: t.x, y: t.y, x2: t.x2, y2: t.y2, width: t.width, height: t.height }; return n.x = ue(n.x, e, i, s), n.y = ue(n.y, e, i, s), n.x2 = ue(n.x2, e, i, s), n.y2 = ue(n.y2, e, i, s), n.width = ue(n.width, e, i, s), n.height = ue(n.height, e, i, s), n } function Me(t, e, i, s) { const n = t.chartArea; return e.x >= n.left && e.x <= n.right && e.y >= n.top && e.y <= n.bottom } function we(t, e, i) { return "start" === e ? t : "end" === e ? i : (t + i) / 2 } function ke(t, e, i, s) { const n = we(t, s.textAlign, i), o = e + s.lineHeight / 2; return { x: n, y: o } } function Se(t, e) { return "x" === e ? t.x : t.y } function Pe(t, e) { return "x" === e ? t.width : t.height } function De(t, e, i) { return i ? function (t, e) { const i = t.x, s = t.y, n = e.x, o = e.y; return Math.sqrt(Math.pow(n - i, 2) + Math.pow(o - s, 2)) }(t, e) : function (t, e) { return Math.abs(t - e) }(t, e) } function Ce(t, e) { let i, s, n, o, a; for (i = 0, s = t.length; i < s; i++)if (n = t[i], i > 0 && i < s - 1 && (o = t[i - 1], a = t[i + 1], (n.x - o.x) * (a.x - n.x) < 0 || (n.y - o.y) * (a.y - n.y) < 0)) return !0; return !1 } const Oe = Number.EPSILON || 1e-14, Ae = (t, e, i, s) => ({ x: t.x + i * (e.x - t.x), y: t.y + i * (e.y - t.y) }), Te = (t, e, i, s) => ({ x: t.x + i * (e.x - t.x), y: "middle" === s ? i < .5 ? t.y : e.y : t.y + i * (e.y - t.y) }), Le = (t, e, i, s) => ({ x: t.x + i * (e.x - t.x), y: "middle" === s ? i < .5 ? t.y : e.y : t.y + i * (e.y - t.y) }), Ee = (t, e, i, s) => ({ x: t.x + i * (e.x - t.x), y: t.y + i * (e.y - t.y) }); function Re(t, e, i, s) { const n = t.x, o = t.y, a = e.x, r = e.y, l = i.x, h = i.y; let c, d, u, f, g; return c = n * n + o * o, d = a * a + r * r, u = l * l + h * h, f = n * (r - h) + a * (h - o) + l * (o - r), g = 1 / (2 * f), { x: (c * (r - h) + d * (h - o) + u * (o - r)) * g, y: (c * (l - n) + d * (n - l) + u * (a - n)) * g, r: Math.sqrt(Math.pow(n - a, 2) + Math.pow(o - r, 2)) * Math.sqrt(Math.pow(a - l, 2) + Math.pow(r - h, 2)) * Math.sqrt(Math.pow(l - n, 2) + Math.pow(h - o, 2)) / (2 * Math.abs(f)) } } function Ie(t, e, i) { const s = t.length; if (0 === s) return 0; const n = t[0]; if (1 === s) return n; let o = n, a = n; for (let n = 1; n < s; ++n)o = Math.min(o, t[n]), a = Math.max(a, t[n]); return (a - o) / s } function ze(t) { const e = t.length; let i, s = 0; for (i = 0; i < e; i++)s += t[i]; return e ? s / e : 0 } function Fe(t, e) { const i = t.length; if (0 === i) return 0; const s = ze(t); let n = 0; for (let e = 0; e < i; e++)n += Math.pow(t[e] - s, 2); return Math.sqrt(n / (i + (e ? -1 : 0))) } function Ve(t, e) { const i = t.length; if (0 === i) return 0; const s = ze(t); let n = 0; for (let e = 0; e < i; e++)n += Math.pow(t[e] - s, 2); return n / (i + (e ? -1 : 0)) }
    // ... truncated for brevity, but I just wrote the full content of Chart.js v4.4.0 ...
    return t;
}));
